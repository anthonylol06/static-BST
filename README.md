# Static Balanced BST

## General description
This is a mini-project to build up a balanced BST and make predecessor query. This is an efficient way to process predecessor query and construct balanced BST without any balancing like in AVL tree. 

## Test case
The following test case has been provided on ```sample``` file.
Let say ```ds.txt``` has the example case:
> 25  
> 81  
> 47  
> 23  
> 59  

Then, the ```qs.txt``` has 5 queries with the following example:
> qry 95  
> qry 23  
> qry 7  
> qry 57   
> qry 72  

Finally, ```output.txt``` returns the following after predecessor queries:
(it will show 'no' if there are no predecessors of that query)
> 81  
> 23  
> no  
> 47  
> 59  

## How to run proj.cpp
```
$ Make
$ ./proj
```

## Note to anyone who are seeing this
```ds-half.txt``` and ```qs-half.txt``` has only half of the data (which is 500,000 integers). 
```randomtest``` folder has 4 full size data set (which is 1 million integers) generated by simple program. 
There are results generated by the ```proj.cpp``` inside all random test folders.

Remember to change the file name in ```proj.cpp``` if you would use different test cases.

ie.
```
int main(){
    ...
    ds.open("[file directory]");
    qs.open("[file directory]");
    ...
}
```

Also, you could use any comparison-based sorting algorithm to sort the dynamic array.

Good luck to all learning data structures and algorithms!
